# -*- coding: utf-8 -*-
"""Copy of SVD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fd6Ruf03Q6UKpm4SO6UHZ13Jq5qEj3FZ
"""

# SVD-based watermarking (non-blind, text watermark)
from google.colab import files
from PIL import Image, ImageDraw, ImageFont
import numpy as np
import cv2
import io
import matplotlib.pyplot as plt
import os
from IPython.display import HTML, display

def upload_image():
    print("Please upload an image file (PNG/JPG). Use the file chooser that appears.")
    uploaded = files.upload()
    if not uploaded:
        raise RuntimeError("No file uploaded")
    name = list(uploaded.keys())[0]
    img = Image.open(io.BytesIO(uploaded[name])).convert('RGB')
    return img, name

def render_text_to_image(text, size, font_size=48):
    # Render text to a grayscale PIL image of given size
    img = Image.new('L', size, color=0)
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("DejaVuSans.ttf", font_size)
    except Exception:
        font = ImageFont.load_default()

    # center text
    if hasattr(draw, "textbbox"):
        bbox = draw.textbbox((0, 0), text, font=font)
        w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
    else:
        w, h = draw.textsize(text, font=font)

    pos = ((size[0] - w) // 2, (size[1] - h) // 2)
    draw.text(pos, text, fill=255, font=font)
    return img

def embed_watermark_svd(cover_pil, watermark_text="CopyRightVIT", alpha=0.02):
    """
    Non-blind SVD watermark embedding:
    - Work in Y (luminance) channel.
    - Compute SVD on cover Y: Uc, Sc, Vct
    - Render watermark text and compute SVD on watermark image (same size): Uw, Sw, Vwt
    - Modify singular values: S_emb = Sc + alpha * Sw
    - Reconstruct Yw = Uc @ diag(S_emb) @ Vct
    """
    img = np.array(cover_pil)
    # convert to YCrCb and take Y
    img_ycc = cv2.cvtColor(img, cv2.COLOR_RGB2YCrCb)
    Y = img_ycc[:, :, 0].astype(np.float32)

    h, w = Y.shape

    # Render watermark exactly the same size as Y (grayscale)
    # Choose font size proportional to image
    font_size = max(12, int(min(h, w) / 8))
    wm_pil = render_text_to_image(watermark_text, (w, h), font_size=font_size)
    wm_arr = np.array(wm_pil).astype(np.float32)

    # Normalize watermark to range similar scale as Y
    # We'll compute SVD on both matrices directly
    # SVD of cover Y
    Uc, Sc, Vct = np.linalg.svd(Y, full_matrices=False)
    # SVD of watermark
    Uw, Sw, Vwt = np.linalg.svd(wm_arr, full_matrices=False)

    # Combine singular values
    # Sc and Sw are 1D arrays of length k=min(h,w)
    S_emb = Sc + alpha * Sw

    # Reconstruct embedded Y
    S_emb_mat = np.diag(S_emb)
    Y_emb = (Uc @ S_emb_mat) @ Vct
    Y_emb = np.clip(Y_emb, 0, 255)

    # Place back into YCrCb and convert to RGB
    img_ycc_w = img_ycc.copy()
    img_ycc_w[:, :, 0] = Y_emb.astype(np.uint8)
    img_rgb_w = cv2.cvtColor(img_ycc_w, cv2.COLOR_YCrCb2RGB)
    watermarked_pil = Image.fromarray(np.clip(img_rgb_w, 0, 255).astype(np.uint8))

    # Return watermarked image and useful intermediate objects (for extraction)
    return watermarked_pil, wm_arr, (Uc, Sc, Vct, Uw, Sw, Vwt)

def extract_watermark_svd(cover_pil, watermarked_pil, Uw, Sw_orig, Vwt, alpha=0.02):
    """
    Non-blind extraction using the original cover and knowledge of Uw and Vwt (from watermark)
    Steps:
    - Compute SVD on cover Y: Uc, Sc, Vct
    - Compute SVD on watermarked Y: Ucw, Sw, Vctw
    - Estimate Sw_est = (Sw - Sc) / alpha
    - Reconstruct watermark_est = Uw @ diag(Sw_est) @ Vwt
    """
    cover = np.array(cover_pil)
    water = np.array(watermarked_pil)

    cover_ycc = cv2.cvtColor(cover, cv2.COLOR_RGB2YCrCb)[:, :, 0].astype(np.float32)
    water_ycc = cv2.cvtColor(water, cv2.COLOR_RGB2YCrCb)[:, :, 0].astype(np.float32)

    # SVDs
    Uc, Sc, Vct = np.linalg.svd(cover_ycc, full_matrices=False)
    Ucw, Sw, Vctw = np.linalg.svd(water_ycc, full_matrices=False)

    # estimate watermark singular values
    Sw_est = (Sw - Sc) / (alpha + 1e-12)

    # Reconstruct approximate watermark using Uw and Vwt (from original watermark SVD)
    S_wm_est_mat = np.diag(Sw_est)
    wm_rec = (Uw @ S_wm_est_mat) @ Vwt
    # normalize to 0-2

from google.colab import files
from PIL import Image, ImageDraw, ImageFont
import numpy as np
import cv2
import io
import matplotlib.pyplot as plt
from IPython.display import HTML, display

def upload_image():
    print("Please upload an image file (PNG/JPG). Use the file chooser that appears.")
    uploaded = files.upload()
    if not uploaded:
        raise RuntimeError("No file uploaded")
    name = list(uploaded.keys())[0]
    img = Image.open(io.BytesIO(uploaded[name])).convert('RGB')
    return img, name

def render_text_to_image(text, size, font_size=48):
    img = Image.new('L', size, color=0)
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("DejaVuSans.ttf", font_size)
    except Exception:
        font = ImageFont.load_default()
    if hasattr(draw, "textbbox"):
        bbox = draw.textbbox((0, 0), text, font=font)
        w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
    else:
        w, h = draw.textsize(text, font=font)
    pos = ((size[0] - w) // 2, (size[1] - h) // 2)
    draw.text(pos, text, fill=255, font=font)
    return img

def embed_watermark_svd(cover_pil, watermark_text="CopyRightVIT", alpha=0.02):
    img = np.array(cover_pil)
    img_ycc = cv2.cvtColor(img, cv2.COLOR_RGB2YCrCb)
    Y = img_ycc[:, :, 0].astype(np.float32)
    h, w = Y.shape
    font_size = max(12, int(min(h, w) / 8))
    wm_pil = render_text_to_image(watermark_text, (w, h), font_size=font_size)
    wm_arr = np.array(wm_pil).astype(np.float32)

    Uc, Sc, Vct = np.linalg.svd(Y, full_matrices=False)
    Uw, Sw, Vwt = np.linalg.svd(wm_arr, full_matrices=False)

    S_emb = Sc + alpha * Sw
    S_emb_mat = np.diag(S_emb)
    Y_emb = (Uc @ S_emb_mat) @ Vct
    Y_emb = np.clip(Y_emb, 0, 255)

    img_ycc_w = img_ycc.copy()
    img_ycc_w[:, :, 0] = Y_emb.astype(np.uint8)
    img_rgb_w = cv2.cvtColor(img_ycc_w, cv2.COLOR_YCrCb2RGB)
    watermarked_pil = Image.fromarray(np.clip(img_rgb_w, 0, 255).astype(np.uint8))

    return watermarked_pil, wm_arr, (Uc, Sc, Vct, Uw, Sw, Vwt)

def extract_watermark_svd(cover_pil, watermarked_pil, Uw, Sw, Vwt, alpha=0.02):
    cover = np.array(cover_pil)
    water = np.array(watermarked_pil)
    cover_ycc = cv2.cvtColor(cover, cv2.COLOR_RGB2YCrCb)[:, :, 0].astype(np.float32)
    water_ycc = cv2.cvtColor(water, cv2.COLOR_RGB2YCrCb)[:, :, 0].astype(np.float32)

    Uc, Sc, Vct = np.linalg.svd(cover_ycc, full_matrices=False)
    Ucw, Sw_w, Vctw = np.linalg.svd(water_ycc, full_matrices=False)

    Sw_est = (Sw_w - Sc) / (alpha + 1e-12)
    S_wm_est_mat = np.diag(Sw_est)
    wm_rec = (Uw @ S_wm_est_mat) @ Vwt
    wm_rec_norm = wm_rec - wm_rec.min()
    if wm_rec_norm.max() > 0:
        wm_rec_norm = wm_rec_norm / wm_rec_norm.max() * 255.0
    wm_rec_uint8 = np.clip(wm_rec_norm, 0, 255).astype(np.uint8)
    wm_bin = (wm_rec_uint8 > 128).astype(np.uint8) * 255
    return Image.fromarray(wm_rec_uint8), Image.fromarray(wm_bin)

# ---------- RUN ----------
img_pil, uploaded_name = upload_image()
print(f"Uploaded: {uploaded_name}, image size: {img_pil.size}")

alpha = 0.02
watermark_text = "CopyRightVIT"

watermarked_pil, wm_arr, svd_objs = embed_watermark_svd(img_pil, watermark_text, alpha=alpha)
Uc, Sc, Vct, Uw, Sw, Vwt = svd_objs

out_path = "watermarked_SVD_CopyRightVIT.png"
watermarked_pil.save(out_path)
print(f"Watermarked image saved to: {out_path}")

extracted_rec_pil, extracted_bin_pil = extract_watermark_svd(img_pil, watermarked_pil, Uw, Sw, Vwt, alpha=alpha)

fig, axes = plt.subplots(1,4, figsize=(20,6))
axes[0].imshow(img_pil); axes[0].set_title("Original"); axes[0].axis('off')
axes[1].imshow(wm_arr, cmap='gray'); axes[1].set_title("Watermark Text"); axes[1].axis('off')
axes[2].imshow(watermarked_pil); axes[2].set_title("Watermarked Image (SVD)"); axes[2].axis('off')
axes[3].imshow(extracted_bin_pil, cmap='gray'); axes[3].set_title("Extracted Watermark"); axes[3].axis('off')
plt.show()

display(HTML(f'<a href="/file={out_path}" target="_blank">Download watermarked image</a>'))

!pip install --quiet opencv-python-headless pillow matplotlib