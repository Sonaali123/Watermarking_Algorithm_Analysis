# -*- coding: utf-8 -*-
"""DWT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r_dLCT_vquiZxb9wfWb3BrnpcZMVk6Zz
"""

!git clone https://github.com/MohamedBakrAli/Kodak-Lossless-True-Color-Image-Suite.git /content/kodak
!mkdir -p /content/dataset/images
!cp -r /content/kodak/* /content/dataset/images/

import numpy as np
import cv2
from PIL import Image
import pywt

def embed_watermark_dwt(cover_pil, watermark_text, alpha=10, wavelet='haar', level=1):
    """Embed a text watermark into the image using DWT (replaces DCT)."""
    img = np.array(cover_pil.convert('L'))  # Convert to grayscale
    img = np.float32(img)

    # Perform DWT
    coeffs2 = pywt.wavedec2(img, wavelet=wavelet, level=level)
    cA, detail_coeffs = coeffs2[0], coeffs2[1:]

    # Convert watermark text to binary
    watermark_bin = ''.join(format(ord(c), '08b') for c in watermark_text)
    watermark_bin = np.array([int(b) for b in watermark_bin])
    wm_len = len(watermark_bin)

    # Embed bits into approximation coefficients (like mid-frequency range)
    i, j = 0, 0
    for bit in watermark_bin:
        # Modify cA values based on bit
        cA[i+10, j+10] += alpha if bit == 1 else -alpha
        j += 1
        if j >= 50:  # move to next row if needed
            j = 0
            i += 1
        if i >= 50:
            break

    # Reconstruct image using inverse DWT
    coeffs2_mod = [cA] + list(detail_coeffs)
    watermarked = pywt.waverec2(coeffs2_mod, wavelet=wavelet)
    watermarked = np.clip(watermarked, 0, 255).astype(np.uint8)
    watermarked_pil = Image.fromarray(watermarked).convert('RGB')

    return watermarked_pil, watermark_bin


def extract_watermark_dwt(cover_pil, watermarked_pil, alpha=10, bit_length=None, wavelet='haar', level=1):
    """Extract the embedded text watermark from the watermarked image using DWT."""
    cover = np.array(cover_pil.convert('L')).astype(np.float32)
    watermarked = np.array(watermarked_pil.convert('L')).astype(np.float32)

    # Perform DWT on both
    coeffs_cover = pywt.wavedec2(cover, wavelet=wavelet, level=level)
    coeffs_water = pywt.wavedec2(watermarked, wavelet=wavelet, level=level)

    cA_c, cA_w = coeffs_cover[0], coeffs_water[0]

    # Determine how many bits to extract
    if bit_length is None:
        bit_length = 400  # fallback

    extracted_bits = []
    i, j = 0, 0
    for _ in range(bit_length):
        diff = cA_w[i+10, j+10] - cA_c[i+10, j+10]
        bit = 1 if diff > 0 else 0
        extracted_bits.append(bit)
        j += 1
        if j >= 50:
            j = 0
            i += 1
        if i >= 50:
            break

    # Convert to image for visualization (square-ish)
    side = int(np.ceil(np.sqrt(bit_length)))
    pad = side * side - bit_length
    extracted_bits_padded = np.pad(extracted_bits, (0, pad), mode='constant')
    watermark_img = np.array(extracted_bits_padded).reshape(side, side) * 255
    watermark_pil = Image.fromarray(watermark_img.astype(np.uint8))

    return watermark_pil, np.array(extracted_bits)

import os
import cv2
import numpy as np
import pandas as pd
from PIL import Image
from skimage.metrics import peak_signal_noise_ratio as psnr, structural_similarity as ssim

# --- Utility metrics ---
def normalized_correlation(w1, w2):
    w1 = w1.flatten().astype(np.float32)
    w2 = w2.flatten().astype(np.float32)
    num = np.sum(w1 * w2)
    den = np.sqrt(np.sum(w1 ** 2) * np.sum(w2 ** 2))
    return num / den if den != 0 else 0

# --- Attack functions ---
def jpeg_compression(img, quality=50):
    encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), quality]
    _, encimg = cv2.imencode('.jpg', img, encode_param)
    decimg = cv2.imdecode(encimg, 1)
    return decimg

def gaussian_noise(img, sigma=10):
    noise = np.random.normal(0, sigma, img.shape).astype(np.float32)
    noisy = np.clip(img + noise, 0, 255).astype(np.uint8)
    return noisy

def rotate_image(img, angle=10):
    h, w = img.shape[:2]
    M = cv2.getRotationMatrix2D((w/2, h/2), angle, 1)
    rotated = cv2.warpAffine(img, M, (w, h))
    return rotated

def crop_image(img, crop_ratio=0.9):
    h, w = img.shape[:2]
    ch, cw = int(h * crop_ratio), int(w * crop_ratio)
    startx = (w - cw) // 2
    starty = (h - ch) // 2
    cropped = img[starty:starty+ch, startx:startx+cw]
    return cv2.resize(cropped, (w, h))

def resize_image(img, scale=0.8):
    h, w = img.shape[:2]
    small = cv2.resize(img, (int(w*scale), int(h*scale)))
    return cv2.resize(small, (w, h))

# --- Import DWT watermarking functions ---
# (Ensure these are defined earlier or imported from your module)
# from your_module import embed_watermark_dwt, extract_watermark_dwt

# --- Main experiment loop ---
dataset_path = "/content/kodak/PhotoCD_PCD0992"
results = []

for fname in os.listdir(dataset_path):
    if not fname.lower().endswith((".jpg", ".png", ".jpeg")):
        continue

    img_path = os.path.join(dataset_path, fname)
    img_pil = Image.open(img_path).convert('RGB')

    # Embed watermark using DWT
    watermarked_pil, watermark_bin = embed_watermark_dwt(img_pil, "CopyRightVIT", alpha=10)

    # Convert to OpenCV format for attacks
    watermarked_cv = cv2.cvtColor(np.array(watermarked_pil), cv2.COLOR_RGB2BGR)
    cover_cv = cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)

    # Define attack scenarios
    attacks = {
        "JPEG_50": jpeg_compression(watermarked_cv, 50),
        "Noise": gaussian_noise(watermarked_cv, 10),
        "Rotate": rotate_image(watermarked_cv, 10),
        "Crop": crop_image(watermarked_cv, 0.9),
        "Resize": resize_image(watermarked_cv, 0.8),
        "None": watermarked_cv  # baseline
    }

    # Evaluate each attack
    for atk_name, atk_img in attacks.items():
        atk_pil = Image.fromarray(cv2.cvtColor(atk_img, cv2.COLOR_BGR2RGB))

        # Extract watermark image and bit sequence
        extracted_pil, extracted_bits = extract_watermark_dwt(
            img_pil,
            atk_pil,
            alpha=10,
            bit_length=len(watermark_bin)
        )

        # Compute metrics
        psnr_val = psnr(np.array(img_pil), np.array(atk_pil))
        ssim_val = ssim(np.array(img_pil), np.array(atk_pil), channel_axis=2)
        nc_val = normalized_correlation(np.array(watermark_bin), np.array(extracted_bits))

        results.append([fname, atk_name, psnr_val, ssim_val, nc_val])

# --- Save results ---
df = pd.DataFrame(results, columns=["Image", "Attack", "PSNR", "SSIM", "NC"])
df.to_csv("/content/dwt_results.csv", index=False)
df.head()