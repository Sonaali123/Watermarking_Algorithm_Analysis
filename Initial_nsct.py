# -*- coding: utf-8 -*-
"""Another copy of NSCT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VFtkzjmYyqFuw5Z2DGKxikdSzP8BGh9l
"""



# NSCT-like watermarking using SWT (Stationary Wavelet Transform) as a practical substitute
# Colab-ready single cell

!pip install --quiet opencv-python-headless pillow matplotlib pywavelets

from google.colab import files
from PIL import Image, ImageDraw, ImageFont
import numpy as np
import cv2
import io
import matplotlib.pyplot as plt
import pywt
from IPython.display import HTML, display

# ------------------ helpers ------------------
def upload_image():
    print("Please upload an image file (PNG/JPG). Use the file chooser that appears.")
    uploaded = files.upload()
    if not uploaded:
        raise RuntimeError("No file uploaded")
    name = list(uploaded.keys())[0]
    img = Image.open(io.BytesIO(uploaded[name])).convert('RGB')
    return img, name

def render_text_to_image(text, size, font_size=48):
    img = Image.new('L', size, color=0)
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("DejaVuSans.ttf", font_size)
    except Exception:
        font = ImageFont.load_default()
    if hasattr(draw, "textbbox"):
        bbox = draw.textbbox((0, 0), text, font=font)
        w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
    else:
        w, h = draw.textsize(text, font=font)
    pos = ((size[0] - w) // 2, (size[1] - h) // 2)
    draw.text(pos, text, fill=255, font=font)
    return img

# ------------------ SWT (NSCT-like) embedding ------------------
def embed_watermark_nsct_like(cover_pil, watermark_text="CopyRightVIT", alpha=0.12, level=2, wavelet='haar'):
    """
    Embed watermark into cover image using Stationary Wavelet Transform (SWT).
    This approximates NSCT behavior (non-subsampled + multi-scale). We embed into the
    approximation (lowpass) coefficients at the specified level (or can embed into detail coeffs).
    Returns: watermarked PIL image, binary watermark array, swt_coeffs_before, swt_coeffs_after
    """
    img = np.array(cover_pil)
    img_ycc = cv2.cvtColor(img, cv2.COLOR_RGB2YCrCb)
    Y = img_ycc[:, :, 0].astype(np.float32)

    # SWT decomposition (level = number of scales). swt2 returns list of (cA, (cH,cV,cD)) per level
    # For convenience, we perform swt2 up to `level` and then use the final approximation cA.
    swt_coeffs = pywt.swt2(Y, wavelet, level=level, start_level=0, axes=(0,1))
    # swt_coeffs is list of tuples: [(cA_L, (ch_L, cv_L, cd_L)), ..., (cA_1, (...))]
    # We'll use the last returned cA (coarsest scale) which is swt_coeffs[-1][0]
    cA = swt_coeffs[-1][0]
    cA_shape = cA.shape  # (h_coarse, w_coarse)

    # Render watermark to same shape as cA
    font_size = max(12, int(min(cA_shape) / 6))
    wm_pil = render_text_to_image(watermark_text, (cA_shape[1], cA_shape[0]), font_size=font_size)
    wm_arr = np.array(wm_pil).astype(np.float32) / 255.0
    wm_bin = (wm_arr > 0.5).astype(np.float32)

    # Scale watermark relative to cA statistics and add
    cA_std = np.std(cA) + 1e-8
    # convert binary to values in [-1,1]
    wm_scaled = (wm_bin - 0.5) * 2.0
    cA_w = cA + alpha * cA_std * wm_scaled

    # build new swt coeffs list but replace last level's cA with cA_w
    swt_coeffs_w = []
    for i, (ca, details) in enumerate(swt_coeffs):
        if i == len(swt_coeffs) - 1:
            swt_coeffs_w.append((cA_w, details))
        else:
            swt_coeffs_w.append((ca, details))

    # Reconstruct using inverse SWT: pywt.iswt2 expects coefficients in order from level 1..level
    # But swt2 returned list from level=level down to 1. So we reorder.
    # pywt.iswt2 expects list [(cA_1,(..)), (cA_2,..), ...] where cA_1 is at level 1 (finest).
    swt_for_iswt = list(reversed(swt_coeffs_w))
    Y_rec = pywt.iswt2(swt_for_iswt, wavelet)
    Y_rec = np.clip(Y_rec, 0, 255).astype(np.uint8)

    img_ycc_w = img_ycc.copy()
    img_ycc_w[:, :, 0] = Y_rec
    img_rgb_w = cv2.cvtColor(img_ycc_w, cv2.COLOR_YCrCb2RGB)
    watermarked_pil = Image.fromarray(np.clip(img_rgb_w, 0, 255).astype(np.uint8))

    return watermarked_pil, wm_bin, swt_coeffs, swt_coeffs_w

# ------------------ Extraction ------------------
def extract_watermark_nsct_like(cover_pil, watermarked_pil, level=2, wavelet='haar', alpha=0.12):
    """
    Non-blind extraction that uses cover and watermarked images:
    - Compute SWT on the cover and watermarked Y channels
    - Take the difference of the coarsest-level approximation coefficients
    - Normalize and threshold to produce a binary watermark image
    """
    cover = np.array(cover_pil)
    water = np.array(watermarked_pil)
    cover_ycc = cv2.cvtColor(cover, cv2.COLOR_RGB2YCrCb)[:, :, 0].astype(np.float32)
    water_ycc = cv2.cvtColor(water, cv2.COLOR_RGB2YCrCb)[:, :, 0].astype(np.float32)

    coeffs_cover = pywt.swt2(cover_ycc, wavelet, level=level, start_level=0, axes=(0,1))
    coeffs_water = pywt.swt2(water_ycc, wavelet, level=level, start_level=0, axes=(0,1))

    cA_c = coeffs_cover[-1][0]
    cA_w = coeffs_water[-1][0]

    diff = cA_w - cA_c
    # Normalize diff to 0-255 and threshold
    diff_norm = diff - diff.min()
    if diff_norm.max() > 0:
        diff_norm = diff_norm / diff_norm.max() * 255.0
    extracted = np.clip(diff_norm, 0, 255).astype(np.uint8)
    extracted_bin = (extracted > 128).astype(np.uint8) * 255

    return Image.fromarray(extracted), Image.fromarray(extracted_bin)

# ------------------ Run cell (Colab) ------------------
img_pil, uploaded_name = upload_image()
print(f"Uploaded: {uploaded_name}, image size: {img_pil.size}")

alpha = 0.12         # embedding strength (tune)
level = 2            # number of SWT scales (higher => larger coarse approx)
wavelet = 'haar'     # wavelet, try 'db1','sym2' etc.

watermarked_pil, wm_bin, swt_before, swt_after = embed_watermark_nsct_like(img_pil, "CopyRightVIT", alpha=alpha, level=level, wavelet=wavelet)

out_path = "watermarked_NSCT_like_CopyRightVIT.png"
watermarked_pil.save(out_path)
print(f"Watermarked image saved to: {out_path}")

extracted_gray_pil, extracted_bin_pil = extract_watermark_nsct_like(img_pil, watermarked_pil, level=level, wavelet=wavelet, alpha=alpha)

# Display results
fig, axes = plt.subplots(1,4, figsize=(20,6))
axes[0].imshow(img_pil); axes[0].set_title("Original"); axes[0].axis('off')
axes[1].imshow(wm_bin, cmap='gray'); axes[1].set_title("Watermark (binary)"); axes[1].axis('off')
axes[2].imshow(watermarked_pil); axes[2].set_title("Watermarked (SWT ~ NSCT)"); axes[2].axis('off')
axes[3].imshow(extracted_bin_pil, cmap='gray'); axes[3].set_title("Extracted (diff)"); axes[3].axis('off')
plt.show()

display(HTML(f'<a href="/file={out_path}" target="_blank">Download watermarked image</a>'))
print("If link doesn't open, run: from google.colab import files; files.download('" + out_path + "')")

from google.colab import files
from PIL import Image, ImageDraw, ImageFont
import numpy as np
import cv2
import io
import matplotlib.pyplot as plt
from IPython.display import HTML, display

def upload_image():
    print("Please upload an image file (PNG/JPG). Use the file chooser that appears.")
    uploaded = files.upload()
    if not uploaded:
        raise RuntimeError("No file uploaded")
    name = list(uploaded.keys())[0]
    img = Image.open(io.BytesIO(uploaded[name])).convert('RGB')
    return img, name

def render_text_to_image(text, size, font_size=48):
    img = Image.new('L', size, color=0)
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("DejaVuSans.ttf", font_size)
    except Exception:
        font = ImageFont.load_default()
    if hasattr(draw, "textbbox"):
        bbox = draw.textbbox((0, 0), text, font=font)
        w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
    else:
        w, h = draw.textsize(text, font=font)
    pos = ((size[0] - w) // 2, (size[1] - h) // 2)
    draw.text(pos, text, fill=255, font=font)
    return img

def embed_watermark_svd(cover_pil, watermark_text="CopyRightVIT", alpha=0.02):
    img = np.array(cover_pil)
    img_ycc = cv2.cvtColor(img, cv2.COLOR_RGB2YCrCb)
    Y = img_ycc[:, :, 0].astype(np.float32)
    h, w = Y.shape
    font_size = max(12, int(min(h, w) / 8))
    wm_pil = render_text_to_image(watermark_text, (w, h), font_size=font_size)
    wm_arr = np.array(wm_pil).astype(np.float32)

    Uc, Sc, Vct = np.linalg.svd(Y, full_matrices=False)
    Uw, Sw, Vwt = np.linalg.svd(wm_arr, full_matrices=False)

    S_emb = Sc + alpha * Sw
    S_emb_mat = np.diag(S_emb)
    Y_emb = (Uc @ S_emb_mat) @ Vct
    Y_emb = np.clip(Y_emb, 0, 255)

    img_ycc_w = img_ycc.copy()
    img_ycc_w[:, :, 0] = Y_emb.astype(np.uint8)
    img_rgb_w = cv2.cvtColor(img_ycc_w, cv2.COLOR_YCrCb2RGB)
    watermarked_pil = Image.fromarray(np.clip(img_rgb_w, 0, 255).astype(np.uint8))

    return watermarked_pil, wm_arr, (Uc, Sc, Vct, Uw, Sw, Vwt)

def extract_watermark_svd(cover_pil, watermarked_pil, Uw, Sw, Vwt, alpha=0.02):
    cover = np.array(cover_pil)
    water = np.array(watermarked_pil)
    cover_ycc = cv2.cvtColor(cover, cv2.COLOR_RGB2YCrCb)[:, :, 0].astype(np.float32)
    water_ycc = cv2.cvtColor(water, cv2.COLOR_RGB2YCrCb)[:, :, 0].astype(np.float32)

    Uc, Sc, Vct = np.linalg.svd(cover_ycc, full_matrices=False)
    Ucw, Sw_w, Vctw = np.linalg.svd(water_ycc, full_matrices=False)

    Sw_est = (Sw_w - Sc) / (alpha + 1e-12)
    S_wm_est_mat = np.diag(Sw_est)
    wm_rec = (Uw @ S_wm_est_mat) @ Vwt
    wm_rec_norm = wm_rec - wm_rec.min()
    if wm_rec_norm.max() > 0:
        wm_rec_norm = wm_rec_norm / wm_rec_norm.max() * 255.0
    wm_rec_uint8 = np.clip(wm_rec_norm, 0, 255).astype(np.uint8)
    wm_bin = (wm_rec_uint8 > 128).astype(np.uint8) * 255
    return Image.fromarray(wm_rec_uint8), Image.fromarray(wm_bin)

# ---------- RUN ----------
img_pil, uploaded_name = upload_image()
print(f"Uploaded: {uploaded_name}, image size: {img_pil.size}")

alpha = 0.02
watermark_text = "CopyRightVIT"

watermarked_pil, wm_arr, svd_objs = embed_watermark_svd(img_pil, watermark_text, alpha=alpha)
Uc, Sc, Vct, Uw, Sw, Vwt = svd_objs

out_path = "watermarked_SVD_CopyRightVIT.png"
watermarked_pil.save(out_path)
print(f"Watermarked image saved to: {out_path}")

extracted_rec_pil, extracted_bin_pil = extract_watermark_svd(img_pil, watermarked_pil, Uw, Sw, Vwt, alpha=alpha)

fig, axes = plt.subplots(1,4, figsize=(20,6))
axes[0].imshow(img_pil); axes[0].set_title("Original"); axes[0].axis('off')
axes[1].imshow(wm_arr, cmap='gray'); axes[1].set_title("Watermark Text"); axes[1].axis('off')
axes[2].imshow(watermarked_pil); axes[2].set_title("Watermarked Image (SVD)"); axes[2].axis('off')
axes[3].imshow(extracted_bin_pil, cmap='gray'); axes[3].set_title("Extracted Watermark"); axes[3].axis('off')
plt.show()

display(HTML(f'<a href="/file={out_path}" target="_blank">Download watermarked image</a>'))

!pip install --quiet opencv-python-headless pillow matplotlib