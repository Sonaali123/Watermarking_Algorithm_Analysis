# -*- coding: utf-8 -*-
"""dwt+svd.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O5P8HZTQSkODiealyZr8GKtw4we1Ihu5
"""

# !pip install pywt scikit-image pillow pandas opencv-python-headless

import os
import cv2
import numpy as np
from PIL import Image, ImageDraw, ImageFont
import pywt
from skimage.metrics import peak_signal_noise_ratio as psnr, structural_similarity as ssim
import pandas as pd

# -------------------- Utilities --------------------
def normalized_correlation(w1, w2):
    w1 = np.array(w1).flatten().astype(np.float32)
    w2 = np.array(w2).flatten().astype(np.float32)
    n = min(w1.size, w2.size)
    w1, w2 = w1[:n], w2[:n]
    num = np.sum(w1 * w2)
    den = np.sqrt(np.sum(w1 ** 2) * np.sum(w2 ** 2))
    return float(num / den) if den != 0 else 0.0

def pil_to_cv2(pil_img):
    return cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)

def cv2_to_pil(cv_img):
    return Image.fromarray(cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB))

# -------------------- Watermark helpers --------------------
def text_to_binary_image(text, size=(64,64), font_size=20):
    W, H = size
    img = Image.new('L', (W, H), color=0)
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("DejaVuSans.ttf", font_size)
    except:
        font = ImageFont.load_default()
    try:
        bbox = draw.textbbox((0, 0), text, font=font)
        w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
    except AttributeError:
        w, h = draw.textsize(text, font=font)
    draw.text(((W - w) / 2, (H - h) / 2), text, fill=255, font=font)

    arr = np.array(img)
    arr = (arr > 127).astype(np.uint8)
    return Image.fromarray((arr * 255).astype(np.uint8))

# -------------------- DWT-SVD core --------------------
def embed_dwt_svd(cover_pil, watermark_pil, alpha=0.12, wavelet='haar'):
    cover_rgb = cover_pil.convert('RGB')
    cover_arr = np.array(cover_rgb).astype(np.float32)
    cover_ycc = cv2.cvtColor(cover_arr.astype(np.uint8), cv2.COLOR_RGB2YCrCb).astype(np.float32)
    Y = cover_ycc[:, :, 0]

    # --- DWT decomposition ---
    coeffs2 = pywt.dwt2(Y, wavelet)
    LL, (LH, HL, HH) = coeffs2

    # --- SVD on LL sub-band ---
    U, S, Vt = np.linalg.svd(LL, full_matrices=False)

    # --- Watermark preparation ---
    wm = watermark_pil.convert('L')
    wm_arr = np.array(wm).astype(np.float32) / 255.0
    wm_flat = cv2.resize(wm_arr, (S.shape[0], 1), interpolation=cv2.INTER_AREA).flatten()

    # --- Embed watermark into singular values ---
    S_w = S + alpha * wm_flat

    # --- Reconstruct modified LL sub-band ---
    LL_mod = U @ np.diag(S_w) @ Vt

    # --- Inverse DWT reconstruction ---
    Y_mod = pywt.idwt2((LL_mod, (LH, HL, HH)), wavelet)
    cover_ycc[:, :, 0] = np.clip(Y_mod, 0, 255)

    watermarked_rgb = cv2.cvtColor(cover_ycc.astype(np.uint8), cv2.COLOR_YCrCb2RGB)
    watermarked_pil = Image.fromarray(watermarked_rgb.astype(np.uint8))

    metadata = {'U': U, 'S': S, 'Vt': Vt, 'wavelet': wavelet, 'alpha': alpha, 'wm_shape': wm_arr.shape}
    return watermarked_pil, metadata


def extract_dwt_svd(cover_pil, attacked_pil, metadata):
    wavelet = metadata['wavelet']
    alpha = metadata['alpha']
    U, S_orig, Vt = metadata['U'], metadata['S'], metadata['Vt']
    wm_shape = metadata['wm_shape']

    atk_arr = np.array(attacked_pil.convert('RGB')).astype(np.float32)
    atk_ycc = cv2.cvtColor(atk_arr.astype(np.uint8), cv2.COLOR_RGB2YCrCb).astype(np.float32)
    Y_atk = atk_ycc[:, :, 0]

    LL_a, _ = pywt.dwt2(Y_atk, wavelet)
    U_a, S_a, Vt_a = np.linalg.svd(LL_a, full_matrices=False)

    # --- Extract watermark from singular values ---
    wm_est = (S_a - S_orig) / (alpha if alpha != 0 else 1e-9)

    # --- Normalize and reshape to image form ---
    wm_norm = (wm_est - wm_est.min()) / (wm_est.max() - wm_est.min() + 1e-9)
    wm_img = (wm_norm * 255).astype(np.uint8).reshape(int(np.sqrt(len(wm_norm))), -1)
    wm_resized = cv2.resize(wm_img, (wm_shape[1], wm_shape[0]), interpolation=cv2.INTER_LINEAR)

    return Image.fromarray(wm_resized)


# -------------------- Attacks --------------------
def jpeg_compression(img, quality=50):
    _, encimg = cv2.imencode('.jpg', img, [int(cv2.IMWRITE_JPEG_QUALITY), quality])
    return cv2.imdecode(encimg, 1)

def gaussian_noise(img, sigma=10):
    noise = np.random.normal(0, sigma, img.shape).astype(np.float32)
    return np.clip(img.astype(np.float32) + noise, 0, 255).astype(np.uint8)

def rotate_image(img, angle=10):
    h, w = img.shape[:2]
    M = cv2.getRotationMatrix2D((w/2, h/2), angle, 1)
    return cv2.warpAffine(img, M, (w, h), borderMode=cv2.BORDER_REFLECT)

def crop_image(img, crop_ratio=0.9):
    h, w = img.shape[:2]
    ch, cw = int(h*crop_ratio), int(w*crop_ratio)
    startx, starty = (w-cw)//2, (h-ch)//2
    cropped = img[starty:starty+ch, startx:startx+cw]
    return cv2.resize(cropped, (w, h))

def resize_image(img, scale=0.8):
    h, w = img.shape[:2]
    return cv2.resize(cv2.resize(img, (int(w*scale), int(h*scale))), (w, h))

# -------------------- Batch Run --------------------
if __name__ == "__main__":
    dataset_dir = "/content/kodak/PhotoCD_PCD0992"
    watermark_text = "CopyRightVIT"
    alpha = 0.12

    wm_pil = text_to_binary_image(watermark_text, size=(64,64), font_size=18)
    all_results = []

    img_files = [f for f in os.listdir(dataset_dir) if f.lower().endswith(('.png','.jpg','.jpeg'))]
    print(f"Found {len(img_files)} images.")

    for fname in img_files:
        img_path = os.path.join(dataset_dir, fname)
        try:
            cover_pil = Image.open(img_path).convert('RGB')
        except:
            print(f"Skipping {fname} (load error)")
            continue

        watermarked_pil, metadata = embed_dwt_svd(cover_pil, wm_pil, alpha=alpha)
        watermarked_cv = pil_to_cv2(watermarked_pil)
        cover_cv = pil_to_cv2(cover_pil)

        attacks = {
            "None": watermarked_cv,
            "JPEG_50": jpeg_compression(watermarked_cv, 50),
            "Noise": gaussian_noise(watermarked_cv, 10),
            "Rotate": rotate_image(watermarked_cv, 10),
            "Crop": crop_image(watermarked_cv, 0.9),
            "Resize": resize_image(watermarked_cv, 0.8),
        }

        wm_arr = np.array(wm_pil.convert('L')).astype(np.float32)/255.0
        original_vector = wm_arr.mean(axis=0)
        original_vector_norm = (original_vector - original_vector.min()) / (original_vector.max()-original_vector.min()+1e-9)

        for atk_name, atk_cv in attacks.items():
            atk_pil = cv2_to_pil(atk_cv)
            extracted_pil = extract_dwt_svd(cover_pil, atk_pil, metadata)

            extracted_arr = np.array(extracted_pil).astype(np.float32)/255.0
            extracted_vector = extracted_arr.mean(axis=0)
            extracted_vector_norm = (extracted_vector - extracted_vector.min()) / (extracted_vector.max()-extracted_vector.min()+1e-9)

            nc_val = normalized_correlation(original_vector_norm, extracted_vector_norm)
            psnr_val = psnr(np.array(cover_pil), np.array(atk_pil))
            ssim_val = ssim(np.array(cover_pil), np.array(atk_pil), channel_axis=2)

            all_results.append([fname, atk_name, psnr_val, ssim_val, nc_val])

    df = pd.DataFrame(all_results, columns=["Image", "Attack", "PSNR", "SSIM", "NC"])
    df.to_csv("/content/dwt_svd_kodak_results.csv", index=False)
    print("✅ Done! Results saved to /content/dwt_svd_kodak_results.csv")
    print(df.head())

import matplotlib.pyplot as plt
import os
import numpy as np
import cv2
from PIL import Image

# ---------- Config ----------
sample_image = "21.png"    # change to any image from your Kodak folder
dataset_dir = "/content/kodak/PhotoCD_PCD0992"  # same as used earlier
watermark_text = "CopyRightVIT"
alpha = 0.12

# ---------- Prepare cover & watermark ----------
cover_pil = Image.open(os.path.join(dataset_dir, sample_image)).convert('RGB')
wm_pil = text_to_binary_image(watermark_text, size=(64,64), font_size=18)

# Embed watermark once (use same metadata for all attacks)
watermarked_pil, metadata = embed_dwt_svd(cover_pil, wm_pil, alpha=alpha)
watermarked_cv = pil_to_cv2(watermarked_pil)

# Prepare original watermark vector (for NC)
wm_arr = np.array(wm_pil.convert('L')).astype(np.float32) / 255.0
original_vector = wm_arr.mean(axis=0)
if original_vector.max() - original_vector.min() != 0:
    original_vector_norm = (original_vector - original_vector.min()) / (original_vector.max() - original_vector.min() + 1e-9)
else:
    original_vector_norm = original_vector

# ---------- Define attacks to visualize ----------
attack_dict = {
    "JPEG_50": jpeg_compression(watermarked_cv, 50),
    "Noise": gaussian_noise(watermarked_cv, 10),
    "Rotate": rotate_image(watermarked_cv, 10),
    "Crop": crop_image(watermarked_cv, 0.9),
    "Resize": resize_image(watermarked_cv, 0.8),
}

# Rows = 1 (original) + len(attacks)
rows = 1 + len(attack_dict)
fig, axes = plt.subplots(rows, 2, figsize=(10, 4 * rows))

results_for_print = []

# --- Row 0: Original image and extracted watermark (no attack) ---
orig_extracted_pil = extract_dwt_svd(cover_pil, watermarked_pil, metadata)
extracted_arr = np.array(orig_extracted_pil).astype(np.float32) / 255.0
extracted_vector = extracted_arr.mean(axis=0)
extracted_vector_norm = (extracted_vector - extracted_vector.min()) / (extracted_vector.max() - extracted_vector.min() + 1e-9)

orig_nc = normalized_correlation(original_vector_norm, extracted_vector_norm)
orig_psnr = psnr(np.array(cover_pil), np.array(watermarked_pil))
orig_ssim = ssim(np.array(cover_pil), np.array(watermarked_pil), channel_axis=2)
results_for_print.append(("Original (Watermarked)", orig_psnr, orig_ssim, orig_nc))

# left cell
ax_img = axes[0, 0]
ax_wm  = axes[0, 1]
ax_img.imshow(watermarked_pil)
ax_img.set_title(f"Watermarked (no attack)\nPSNR={orig_psnr:.2f}, SSIM={orig_ssim:.3f}")
ax_img.axis('off')

# right cell: extracted watermark
ax_wm.imshow(orig_extracted_pil.convert('L'), cmap='gray', vmin=0, vmax=255)
ax_wm.set_title(f"Extracted WM (original)\nNC={orig_nc:.3f}")
ax_wm.axis('off')

# --- Subsequent rows: each attack and its extracted watermark ---
for idx, (atk_name, atk_cv) in enumerate(attack_dict.items(), start=1):
    atk_pil = cv2_to_pil(atk_cv)

    # Extract watermark from attacked image
    extracted_pil = extract_dwt_svd(cover_pil, atk_pil, metadata)
    extracted_arr = np.array(extracted_pil).astype(np.float32) / 255.0
    extracted_vector = extracted_arr.mean(axis=0)
    extracted_vector_norm = (extracted_vector - extracted_vector.min()) / (extracted_vector.max() - extracted_vector.min() + 1e-9)

    # Compute metrics
    psnr_val = psnr(np.array(cover_pil), np.array(atk_pil))
    ssim_val = ssim(np.array(cover_pil), np.array(atk_pil), channel_axis=2)
    nc_val = normalized_correlation(original_vector_norm, extracted_vector_norm)
    results_for_print.append((atk_name, psnr_val, ssim_val, nc_val))

    # Plot images
    ax_img = axes[idx, 0]
    ax_wm  = axes[idx, 1]

    ax_img.imshow(atk_pil)
    ax_img.set_title(f"{atk_name}\nPSNR={psnr_val:.2f}, SSIM={ssim_val:.3f}")
    ax_img.axis('off')

    ax_wm.imshow(extracted_pil.convert('L'), cmap='gray', vmin=0, vmax=255)
    ax_wm.set_title(f"Extracted WM\nNC={nc_val:.3f}")
    ax_wm.axis('off')

plt.tight_layout()
out_path = f"/content/comparison_{os.path.splitext(sample_image)[0]}.png"
fig.savefig(out_path, bbox_inches='tight', dpi=150)
print(f"✅ Saved comparison figure to: {out_path}\n")

# Print numeric results
print("Attack\t\t\tPSNR\t\tSSIM\t\tNC")
for r in results_for_print:
    print(f"{r[0]:20s}\t{r[1]:6.2f}\t\t{r[2]:.3f}\t\t{r[3]:.3f}")

plt.show()

!git clone https://github.com/MohamedBakrAli/Kodak-Lossless-True-Color-Image-Suite.git /content/kodak
!mkdir -p /content/dataset/images
!cp -r /content/kodak/* /content/dataset/images/