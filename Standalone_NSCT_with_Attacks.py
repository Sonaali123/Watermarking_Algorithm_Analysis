# -*- coding: utf-8 -*-
"""NSCT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bUU3nn5ZFNg3i0s6O0G33QrzCxG1MYjA
"""

!pip install pynsct

!git clone https://github.com/MohamedBakrAli/Kodak-Lossless-True-Color-Image-Suite.git /content/kodak
!mkdir -p /content/dataset/images
!cp -r /content/kodak/* /content/dataset/images/

!pip install --quiet opencv-python-headless pillow matplotlib pywavelets

import numpy as np
import cv2
from PIL import Image, ImageDraw, ImageFont
import pywt
import matplotlib.pyplot as plt
from IPython.display import display, HTML

# ---------- Utility ----------
def render_text_to_image(text, size, font_size=48):
    img = Image.new('L', size, color=0)
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("DejaVuSans.ttf", font_size)
    except:
        font = ImageFont.load_default()
    if hasattr(draw, "textbbox"):
        bbox = draw.textbbox((0, 0), text, font=font)
        w, h = bbox[2]-bbox[0], bbox[3]-bbox[1]
    else:
        w, h = draw.textsize(text, font=font)
    pos = ((size[0]-w)//2, (size[1]-h)//2)
    draw.text(pos, text, fill=255, font=font)
    return img


# ---------- NSCT-like (SWT) Embedding ----------
def embed_watermark_nsct(cover_pil, watermark_text="CopyRightVIT", alpha=0.12, level=2, wavelet='haar'):
    """Embed a text watermark using NSCT-like (SWT) transform."""
    img = np.array(cover_pil.convert('L')).astype(np.float32)
    h, w = img.shape

    # SWT decomposition
    swt_coeffs = pywt.swt2(img, wavelet, level=level)
    cA = swt_coeffs[-1][0]  # coarsest approx

    # Convert text to binary (like original DCT logic)
    watermark_bin = ''.join(format(ord(c), '08b') for c in watermark_text)
    watermark_bin = np.array([int(b) for b in watermark_bin])
    wm_len = len(watermark_bin)

    # Embed bits into middle region of cA
    cA_mod = cA.copy()
    i, j = 0, 0
    for bit in watermark_bin:
        cA_mod[i+10, j+10] += alpha * (1 if bit == 1 else -1)
        j += 1
        if j >= 50:
            j = 0
            i += 1
        if i >= 50:
            break

    # Replace cA with modified one
    swt_coeffs_w = []
    for idx, (ca, details) in enumerate(swt_coeffs):
        if idx == len(swt_coeffs) - 1:
            swt_coeffs_w.append((cA_mod, details))
        else:
            swt_coeffs_w.append((ca, details))

    # Inverse SWT reconstruction
    Y_rec = pywt.iswt2(list(reversed(swt_coeffs_w)), wavelet)
    Y_rec = np.clip(Y_rec, 0, 255).astype(np.uint8)

    watermarked_pil = Image.fromarray(Y_rec).convert('RGB')
    return watermarked_pil, watermark_bin


# ---------- NSCT-like (SWT) Extraction ----------
def extract_watermark_nsct(cover_pil, watermarked_pil, alpha=0.12, level=2, wavelet='haar', bit_length=None):
    """Extract embedded watermark using NSCT-like transform."""
    cover = np.array(cover_pil.convert('L')).astype(np.float32)
    watermarked = np.array(watermarked_pil.convert('L')).astype(np.float32)

    # SWT on both
    coeffs_cover = pywt.swt2(cover, wavelet, level=level)
    coeffs_water = pywt.swt2(watermarked, wavelet, level=level)

    cA_c = coeffs_cover[-1][0]
    cA_w = coeffs_water[-1][0]

    # Default bit length
    if bit_length is None:
        bit_length = 400

    extracted_bits = []
    i, j = 0, 0
    for _ in range(bit_length):
        diff = cA_w[i+10, j+10] - cA_c[i+10, j+10]
        bit = 1 if diff > 0 else 0
        extracted_bits.append(bit)
        j += 1
        if j >= 50:
            j = 0
            i += 1
        if i >= 50:
            break

    # Visualize extracted watermark bits
    side = int(np.ceil(np.sqrt(bit_length)))
    pad = side * side - bit_length
    extracted_bits_padded = np.pad(extracted_bits, (0, pad), mode='constant')
    watermark_img = np.array(extracted_bits_padded).reshape(side, side) * 255
    watermark_pil = Image.fromarray(watermark_img.astype(np.uint8))

    return watermark_pil, np.array(extracted_bits)

!pip install --quiet opencv-python-headless pillow matplotlib pywavelets scikit-image pandas

import os
import cv2
import numpy as np
from PIL import Image
from skimage.metrics import peak_signal_noise_ratio as psnr, structural_similarity as ssim
import pywt
import pandas as pd

# --- Metrics ---
def normalized_correlation(w1, w2):
    w1 = w1.flatten().astype(np.float32)
    w2 = w2.flatten().astype(np.float32)
    num = np.sum(w1 * w2)
    den = np.sqrt(np.sum(w1 ** 2) * np.sum(w2 ** 2))
    return num / den if den != 0 else 0


# --- NSCT (SWT-like) watermarking functions ---
def embed_watermark_nsct(cover_pil, watermark_text="CopyRightVIT", alpha=0.12, level=2, wavelet='haar'):
    img = np.array(cover_pil.convert('L')).astype(np.float32)
    swt_coeffs = pywt.swt2(img, wavelet, level=level)
    cA = swt_coeffs[-1][0]

    watermark_bin = ''.join(format(ord(c), '08b') for c in watermark_text)
    watermark_bin = np.array([int(b) for b in watermark_bin])
    wm_len = len(watermark_bin)

    cA_mod = cA.copy()
    i, j = 0, 0
    for bit in watermark_bin:
        cA_mod[i+10, j+10] += alpha * (1 if bit == 1 else -1)
        j += 1
        if j >= 50:
            j = 0
            i += 1
        if i >= 50:
            break

    swt_coeffs_w = []
    for idx, (ca, details) in enumerate(swt_coeffs):
        if idx == len(swt_coeffs) - 1:
            swt_coeffs_w.append((cA_mod, details))
        else:
            swt_coeffs_w.append((ca, details))

    img_rec = pywt.iswt2(list(reversed(swt_coeffs_w)), wavelet)
    img_rec = np.clip(img_rec, 0, 255).astype(np.uint8)
    watermarked_pil = Image.fromarray(img_rec).convert('RGB')
    return watermarked_pil, watermark_bin


def extract_watermark_nsct(cover_pil, watermarked_pil, alpha=0.12, level=2, wavelet='haar', bit_length=None):
    cover = np.array(cover_pil.convert('L')).astype(np.float32)
    watermarked = np.array(watermarked_pil.convert('L')).astype(np.float32)

    coeffs_cover = pywt.swt2(cover, wavelet, level=level)
    coeffs_water = pywt.swt2(watermarked, wavelet, level=level)
    cA_c = coeffs_cover[-1][0]
    cA_w = coeffs_water[-1][0]

    if bit_length is None:
        bit_length = 400

    extracted_bits = []
    i, j = 0, 0
    for _ in range(bit_length):
        diff = cA_w[i+10, j+10] - cA_c[i+10, j+10]
        bit = 1 if diff > 0 else 0
        extracted_bits.append(bit)
        j += 1
        if j >= 50:
            j = 0
            i += 1
        if i >= 50:
            break

    return None, np.array(extracted_bits)


# --- Attack functions ---
def jpeg_compression(img, quality=50):
    encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), quality]
    _, encimg = cv2.imencode('.jpg', img, encode_param)
    decimg = cv2.imdecode(encimg, 1)
    return decimg

def gaussian_noise(img, sigma=10):
    noise = np.random.normal(0, sigma, img.shape).astype(np.float32)
    noisy = np.clip(img + noise, 0, 255).astype(np.uint8)
    return noisy

def rotate_image(img, angle=10):
    h, w = img.shape[:2]
    M = cv2.getRotationMatrix2D((w/2, h/2), angle, 1)
    rotated = cv2.warpAffine(img, M, (w, h))
    return rotated

def crop_image(img, crop_ratio=0.9):
    h, w = img.shape[:2]
    ch, cw = int(h * crop_ratio), int(w * crop_ratio)
    startx = (w - cw) // 2
    starty = (h - ch) // 2
    cropped = img[starty:starty+ch, startx:startx+cw]
    return cv2.resize(cropped, (w, h))

def resize_image(img, scale=0.8):
    h, w = img.shape[:2]
    small = cv2.resize(img, (int(w*scale), int(h*scale)))
    return cv2.resize(small, (w, h))


# --- Main Experiment ---
dataset_path = "/content/kodak/PhotoCD_PCD0992"
results = []

for fname in os.listdir(dataset_path):
    if not fname.lower().endswith((".jpg", ".png", ".jpeg")):
        continue

    img_path = os.path.join(dataset_path, fname)
    img_pil = Image.open(img_path).convert('RGB')

    # Embed watermark
    watermarked_pil, watermark_bin = embed_watermark_nsct(img_pil, "CopyRightVIT", alpha=0.12)

    # Convert to OpenCV for attacks
    watermarked_cv = cv2.cvtColor(np.array(watermarked_pil), cv2.COLOR_RGB2BGR)
    cover_cv = cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)

    # Attacks
    attacks = {
        "JPEG_50": jpeg_compression(watermarked_cv, 50),
        "Noise": gaussian_noise(watermarked_cv, 10),
        "Rotate": rotate_image(watermarked_cv, 10),
        "Crop": crop_image(watermarked_cv, 0.9),
        "Resize": resize_image(watermarked_cv, 0.8),
        "None": watermarked_cv
    }

    # Evaluate
    for atk_name, atk_img in attacks.items():
        atk_pil = Image.fromarray(cv2.cvtColor(atk_img, cv2.COLOR_BGR2RGB))
        _, extracted_bits = extract_watermark_nsct(img_pil, atk_pil, alpha=0.12, bit_length=len(watermark_bin))

        psnr_val = psnr(np.array(img_pil), np.array(atk_pil))
        ssim_val = ssim(np.array(img_pil), np.array(atk_pil), channel_axis=2)
        nc_val = normalized_correlation(np.array(watermark_bin), np.array(extracted_bits))

        results.append([fname, atk_name, psnr_val, ssim_val, nc_val])


# --- Save Results ---
df = pd.DataFrame(results, columns=["Image", "Attack", "PSNR", "SSIM", "NC"])
df.to_csv("/content/nsct_results.csv", index=False)
print("âœ… Results saved to /content/nsct_results.csv")
df.head()