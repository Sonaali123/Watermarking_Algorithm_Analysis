# -*- coding: utf-8 -*-
"""Untitled82.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K7yJDuE4VqiqSctKfndoh60fWA8IQjWO
"""

# ---------- STEP 1 : DWT + SVD Watermark Embedding ----------
import cv2, numpy as np, pywt
from PIL import Image, ImageDraw, ImageFont

# ---------- Create binary watermark ----------
def text_to_binary_image(text, size=(64,64), font_size=18):
    img = Image.new('L', size, color=0)
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("DejaVuSans.ttf", font_size)
    except:
        font = ImageFont.load_default()

    # Handle both new and old Pillow versions
    try:
        bbox = draw.textbbox((0, 0), text, font=font)
        w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
    except AttributeError:
        w, h = draw.textsize(text, font=font)

    draw.text(((size[0]-w)/2, (size[1]-h)/2), text, fill=255, font=font)
    return img



# ---------- DWT + SVD embedding ----------
def embed_dwt_svd(cover_pil, watermark_pil, alpha=0.12, wavelet='haar'):
    cover_rgb = cover_pil.convert('RGB')
    cover_arr = np.array(cover_rgb).astype(np.float32)
    cover_ycc = cv2.cvtColor(cover_arr.astype(np.uint8), cv2.COLOR_RGB2YCrCb).astype(np.float32)
    Y = cover_ycc[:,:,0]

    # Apply 1-level DWT
    LL, (LH, HL, HH) = pywt.dwt2(Y, wavelet)

    # SVD on LL band
    U, S, Vt = np.linalg.svd(LL, full_matrices=False)

    # Prepare watermark
    wm = np.array(watermark_pil.convert('L')).astype(np.float32) / 255.0
    wm_resized = cv2.resize(wm, (S.shape[0], 1)).flatten()

    # Embed watermark in singular values
    S_w = S + alpha * wm_resized

    # Reconstruct modified LL
    LL_mod = U @ np.diag(S_w) @ Vt
    Y_mod = pywt.idwt2((LL_mod, (LH, HL, HH)), wavelet)

    cover_ycc[:,:,0] = np.clip(Y_mod, 0, 255)
    watermarked_rgb = cv2.cvtColor(cover_ycc.astype(np.uint8), cv2.COLOR_YCrCb2RGB)

    metadata = {'U':U, 'S':S, 'Vt':Vt, 'wavelet':wavelet, 'alpha':alpha, 'wm_shape':wm.shape}
    return Image.fromarray(watermarked_rgb.astype(np.uint8)), metadata


# ---------- MAIN ----------
image_path = "/content/kodak/PhotoCD_PCD0992/21.png"   # Choose your Kodak image
watermark_text = "CopyRightVIT"

cover_pil = Image.open(image_path).convert('RGB')
wm_pil = text_to_binary_image(watermark_text)

# Embed watermark
watermarked_pil, meta = embed_dwt_svd(cover_pil, wm_pil, alpha=0.12)

# Save results
watermarked_pil.save("/content/watermarked_dwt_svd.png")
np.savez("/content/dwt_svd_meta.npz", **meta)
wm_pil.save("/content/original_watermark.png")

print("‚úÖ Watermarked image saved at /content/watermarked_dwt_svd.png")
print("üíæ Metadata saved at /content/dwt_svd_meta.npz")
print("üìú Original watermark saved at /content/original_watermark.png")

!git clone https://github.com/MohamedBakrAli/Kodak-Lossless-True-Color-Image-Suite.git /content/kodak
!mkdir -p /content/dataset/images
!cp -r /content/kodak/* /content/dataset/images/

# ---------- STEP 2 : WhatsApp Robustness Evaluation ----------
import numpy as np, cv2, pywt, os, pandas as pd
from PIL import Image
from skimage.metrics import peak_signal_noise_ratio as psnr, structural_similarity as ssim

# ---------- Helper : Normalized Correlation ----------
def normalized_correlation(w1, w2):
    w1, w2 = np.array(w1).flatten(), np.array(w2).flatten()
    n = min(w1.size, w2.size)
    w1, w2 = w1[:n], w2[:n]
    num = np.sum(w1*w2)
    den = np.sqrt(np.sum(w1**2) * np.sum(w2**2))
    return float(num/den) if den != 0 else 0.0

# ---------- Watermark extraction ----------
def extract_dwt_svd(attacked_pil, metadata):
    wavelet = str(metadata["wavelet"])
    alpha = float(metadata["alpha"])
    U, S, Vt = metadata["U"], metadata["S"], metadata["Vt"]
    wm_shape = tuple(metadata["wm_shape"])

    atk_arr = np.array(attacked_pil.convert("RGB")).astype(np.float32)
    atk_ycc = cv2.cvtColor(atk_arr.astype(np.uint8), cv2.COLOR_RGB2YCrCb).astype(np.float32)
    Y = atk_ycc[:, :, 0]

    LL_a, _ = pywt.dwt2(Y, wavelet)
    U_a, S_a, Vt_a = np.linalg.svd(LL_a, full_matrices=False)

    wm_est = (S_a - S) / (alpha if alpha != 0 else 1e-9)
    wm_norm = (wm_est - wm_est.min()) / (wm_est.max() - wm_est.min() + 1e-9)
    wm_img = (wm_norm * 255).astype(np.uint8).reshape(int(np.sqrt(len(wm_norm))), -1)
    wm_resized = cv2.resize(wm_img, (wm_shape[1], wm_shape[0]), interpolation=cv2.INTER_LINEAR)
    return Image.fromarray(wm_resized)

# ---------- Load metadata + original watermark ----------
meta = np.load("/content/dwt_svd_meta.npz", allow_pickle=True)
original_wm = Image.open("/content/original_watermark.png").convert("L")

# ---------- Paths for received WhatsApp images ----------
received_images = {
    "WhatsApp_NonHD": "/content/received_whatsapp_nonHD.jpeg",
    "WhatsApp_HD": "/content/received_whatsapp_HD.png"
}

# ---------- Run extraction + compute metrics ----------
results = []
cover_path = "/content/kodak/PhotoCD_PCD0992/21.png"
cover_pil = Image.open(cover_path).convert("RGB")

for mode, path in received_images.items():
    if not os.path.exists(path):
        print(f"‚ö†Ô∏è Missing file: {path}")
        continue

    atk_pil = Image.open(path).convert("RGB")
    extracted_pil = extract_dwt_svd(atk_pil, meta)
    extracted_pil.save(f"/content/extracted_{mode}.png")

    # Compute metrics
    psnr_val = psnr(np.array(cover_pil), np.array(atk_pil))
    ssim_val = ssim(np.array(cover_pil), np.array(atk_pil), channel_axis=2)

    wm_arr = np.array(original_wm).astype(np.float32) / 255.0
    extracted_arr = np.array(extracted_pil).astype(np.float32) / 255.0
    nc_val = normalized_correlation(wm_arr, extracted_arr)

    results.append([mode, psnr_val, ssim_val, nc_val])

# ---------- Display clean table ----------
df = pd.DataFrame(results, columns=["Transmission Type", "PSNR (dB)", "SSIM", "NC"])
print("\nüìä WhatsApp Transmission Robustness Results:\n")
print(df.to_string(index=False))

# ---------- Save report ----------
df.to_csv("/content/dwt_svd_whatsapp_results.csv", index=False)
print("\n‚úÖ Results saved to /content/dwt_svd_whatsapp_results.csv")