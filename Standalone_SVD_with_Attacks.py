# -*- coding: utf-8 -*-
"""SVD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uf8xa__Sbu6yQXNpKcH8pw1Rd3ftDPEy
"""

!git clone https://github.com/MohamedBakrAli/Kodak-Lossless-True-Color-Image-Suite.git /content/kodak
!mkdir -p /content/dataset/images
!cp -r /content/kodak/* /content/dataset/images/

"""## **SVD**"""

def embed_watermark_svd(cover_pil, watermark_text, alpha=10):
    """Embed a text watermark into the image using SVD."""
    img = np.array(cover_pil.convert('L')).astype(np.float32)  # grayscale

    # SVD of the cover image
    U, S, Vt = np.linalg.svd(img, full_matrices=False)

    # Convert watermark text to binary
    watermark_bin = ''.join(format(ord(c), '08b') for c in watermark_text)
    watermark_bin = np.array([int(b) for b in watermark_bin])
    wm_len = len(watermark_bin)

    # Embed watermark bits into singular values
    S_mod = S.copy()
    for idx, bit in enumerate(watermark_bin):
        if idx >= len(S_mod):
            break
        S_mod[idx] += alpha if bit == 1 else -alpha

    # Reconstruct watermarked image
    watermarked = np.dot(U, np.dot(np.diag(S_mod), Vt))
    watermarked = np.clip(watermarked, 0, 255).astype(np.uint8)
    watermarked_pil = Image.fromarray(watermarked).convert('RGB')

    return watermarked_pil, watermark_bin



def extract_watermark_svd(cover_pil, watermarked_pil, alpha=10, bit_length=None):
    """Extract the text watermark using SVD (non-blind extraction)."""
    cover = np.array(cover_pil.convert('L')).astype(np.float32)
    watermarked = np.array(watermarked_pil.convert('L')).astype(np.float32)

    # SVD of original and watermarked image
    Uc, Sc, Vct = np.linalg.svd(cover, full_matrices=False)
    Uw, Sw, Vwt = np.linalg.svd(watermarked, full_matrices=False)

    if bit_length is None:
        bit_length = 400

    extracted_bits = []
    for i in range(bit_length):
        if i >= len(Sc):
            extracted_bits.append(0)
            continue

        diff = Sw[i] - Sc[i]
        bit = 1 if diff > 0 else 0
        extracted_bits.append(bit)

    # Create watermark image (square mask)
    side = int(np.ceil(np.sqrt(bit_length)))
    pad = side * side - bit_length
    extracted_bits_padded = np.pad(extracted_bits, (0, pad), mode='constant')
    watermark_image = np.array(extracted_bits_padded).reshape(side, side) * 255

    watermark_pil = Image.fromarray(watermark_image.astype(np.uint8))

    return watermark_pil, np.array(extracted_bits)

import os
import cv2
import numpy as np
from PIL import Image
from skimage.metrics import peak_signal_noise_ratio as psnr, structural_similarity as ssim
import pandas as pd

# --- Utility metrics ---
def normalized_correlation(w1, w2):
    w1 = w1.flatten().astype(np.float32)
    w2 = w2.flatten().astype(np.float32)
    num = np.sum(w1 * w2)
    den = np.sqrt(np.sum(w1 ** 2) * np.sum(w2 ** 2))
    return num / den if den != 0 else 0

# --- Attack functions ---
def jpeg_compression(img, quality=50):
    encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), quality]
    _, encimg = cv2.imencode('.jpg', img, encode_param)
    decimg = cv2.imdecode(encimg, 1)
    return decimg

def gaussian_noise(img, sigma=10):
    noise = np.random.normal(0, sigma, img.shape).astype(np.float32)
    noisy = np.clip(img + noise, 0, 255).astype(np.uint8)
    return noisy

def rotate_image(img, angle=10):
    h, w = img.shape[:2]
    M = cv2.getRotationMatrix2D((w/2, h/2), angle, 1)
    rotated = cv2.warpAffine(img, M, (w, h))
    return rotated

def crop_image(img, crop_ratio=0.9):
    h, w = img.shape[:2]
    ch, cw = int(h * crop_ratio), int(w * crop_ratio)
    startx = (w - cw) // 2
    starty = (h - ch) // 2
    cropped = img[starty:starty+ch, startx:startx+cw]
    return cv2.resize(cropped, (w, h))

def resize_image(img, scale=0.8):
    h, w = img.shape[:2]
    small = cv2.resize(img, (int(w*scale), int(h*scale)))
    small = cv2.resize(small, (w, h))
    return small


# --- Main experiment loop ---
dataset_path = "/content/kodak/PhotoCD_PCD0992"
results = []

for fname in os.listdir(dataset_path):
    if not fname.lower().endswith((".jpg", ".png", ".jpeg")):
        continue

    img_path = os.path.join(dataset_path, fname)
    img_pil = Image.open(img_path).convert('RGB')

    # Embed watermark
    watermarked_pil, watermark_bin = embed_watermark_svd(
        img_pil, "CopyRightVIT", alpha=15
    )

    # Convert for attacks
    watermarked_cv = cv2.cvtColor(np.array(watermarked_pil), cv2.COLOR_RGB2BGR)
    cover_cv = cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)

    attacks = {
        "JPEG_50": jpeg_compression(watermarked_cv, 50),
        "Noise": gaussian_noise(watermarked_cv, 10),
        "Rotate": rotate_image(watermarked_cv, 10),
        "Crop": crop_image(watermarked_cv, 0.9),
        "Resize": resize_image(watermarked_cv, 0.8),
        "None": watermarked_cv
    }

    for atk_name, atk_img in attacks.items():
        atk_pil = Image.fromarray(cv2.cvtColor(atk_img, cv2.COLOR_BGR2RGB))

        extracted_pil, extracted_bits = extract_watermark_svd(
            img_pil, atk_pil, alpha=15, bit_length=len(watermark_bin)
        )

        psnr_val = psnr(np.array(img_pil), np.array(atk_pil))
        ssim_val = ssim(np.array(img_pil), np.array(atk_pil), channel_axis=2)
        nc_val = normalized_correlation(np.array(watermark_bin), np.array(extracted_bits))

        results.append([fname, atk_name, psnr_val, ssim_val, nc_val])

# --- Save results ---
import pandas as pd
df = pd.DataFrame(results, columns=["Image", "Attack", "PSNR", "SSIM", "NC"])
df.to_csv("/content/svd_results.csv", index=False)
df.head()